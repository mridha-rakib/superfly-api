// file: src/modules/user/user.repository.ts

import { ACCOUNT_STATUS } from "@/constants/app.constants";
import { logger } from "@/middlewares/pino-logger";
import { BaseRepository } from "@/modules/base/base.repository";
import type { IUser } from "./user.interface";
import { RefreshTokenBlacklist, User } from "./user.model";

/**
 * User Repository
 */
export class UserRepository extends BaseRepository<IUser> {
  constructor() {
    super(User);
  }

  async findByEmail(email: string): Promise<IUser | null> {
    return this.model
      .findOne({ email: email.toLowerCase(), isDeleted: false })
      .exec();
  }

  async findByEmailWithPassword(email: string): Promise<IUser | null> {
    return this.model
      .findOne({ email: email.toLowerCase(), isDeleted: false })
      .select("+password")
      .exec();
  }

  async findByVerificationToken(token: string): Promise<IUser | null> {
    return this.model
      .findOne({
        emailVerificationToken: token,
        isDeleted: false,
      })
      .select("+emailVerificationToken +emailVerificationExpiresAt")
      .exec();
  }

  async findByRole(role: string): Promise<IUser[]> {
    return this.model.find({ role, isDeleted: false }).exec();
  }

  async findByAccountStatus(status: string): Promise<IUser[]> {
    return this.model.find({ accountStatus: status, isDeleted: false }).exec();
  }

  async markEmailAsVerified(userId: string): Promise<IUser | null> {
    return this.model
      .findByIdAndUpdate(
        userId,
        {
          emailVerified: true,
          emailVerificationToken: undefined,
          emailVerificationExpiresAt: undefined,
          accountStatus: ACCOUNT_STATUS.ACTIVE,
        },
        { new: true }
      )
      .exec();
  }

  async updateVerificationToken(
    userId: string,
    data: {
      emailVerificationToken?: string;
      emailVerificationExpiresAt?: Date;
    }
  ): Promise<IUser | null> {
    return this.model.findByIdAndUpdate(userId, data, { new: true }).exec();
  }

  async updatePassword(
    userId: string,
    hashedPassword: string
  ): Promise<IUser | null> {
    return this.model
      .findByIdAndUpdate(
        userId,
        {
          password: hashedPassword,
          passwordChangedAt: new Date(),
          mustChangePassword: false,
          passwordAutoGenerated: false,
        },
        { new: true }
      )
      .exec();
  }

  async updateLastLogin(userId: string): Promise<IUser | null> {
    return this.model
      .findByIdAndUpdate(userId, { lastLoginAt: new Date() }, { new: true })
      .exec();
  }

  async permanentlyDeleteUser(userId: string): Promise<any> {
    return this.model.deleteOne({ _id: userId }).exec();
  }

  async countByRole(role: string): Promise<number> {
    return this.model.countDocuments({ role, isDeleted: false }).exec();
  }

  async countActiveUsers(): Promise<number> {
    return this.model
      .countDocuments({ accountStatus: ACCOUNT_STATUS.ACTIVE, isDeleted: false })
      .exec();
  }

  async findByIdWithPassword(userId: string): Promise<IUser | null> {
    return this.model.findById(userId).select("+password").exec();
  }

  async deleteAllRefreshTokens(userId: string): Promise<number> {
    try {
      const result = await RefreshTokenBlacklist.deleteMany({
        userId: userId,
      });

      return result.deletedCount || 0;
    } catch (error) {
      logger.error({ userId, error }, "Error deleting refresh tokens");
      throw error;
    }
  }

  async isRefreshTokenRevoked(token: string): Promise<boolean> {
    const exists = await RefreshTokenBlacklist.exists({ token });
    return Boolean(exists);
  }

  async blacklistRefreshToken(data: {
    userId: string;
    token: string;
    expiresAt: Date;
    reason?: "logout" | "password_change" | "security_incident" | "admin_action";
  }): Promise<void> {
    const { userId, token, expiresAt, reason = "admin_action" } = data;

    await RefreshTokenBlacklist.updateOne(
      { token },
      {
        $setOnInsert: {
          userId,
          token,
          expiresAt,
          reason,
        },
      },
      { upsert: true }
    ).exec();
  }
}
